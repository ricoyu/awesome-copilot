package com.awesomecopilot.algorithm.leetcode.round3;

/**
 * 第 N 个泰波那契数
 * <p>
 * 泰波那契序列 Tn 定义如下：
 * <p>
 * T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
 * <p>
 * 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
 * <p>
 * 示例 1：<br/>
 * 输入：n = 4 <br/>
 * 输出：4 <p/>
 * 解释： <br/>
 * T_3 = 0 + 1 + 1 = 2 <br/>
 * T_4 = 1 + 1 + 2 = 4
 * <p/>
 * 示例 2： <br/>
 * 输入：n = 25 <br/>
 * 输出：1389537
 * <p>
 * 首先，我得理解这个问题。泰波那契数列和斐波那契数列类似，但斐波那契是前两项之和，而这里是前三项之和。
 * 那递归的话可能会很慢，因为每次都要重复计算很多项。比如当n比较大的时候，比如示例中的25，递归的效率可能很低，甚至导致栈溢出或者超时。
 * 所以得考虑用更高效的方法，比如动态规划或者迭代的方法。
 * <p>
 * 那动态规划应该怎么做呢？动态规划通常会把大问题分解成小问题，然后存储中间结果。比如这里，每个Tn的值都依赖于前三项，所以可以用一个数组来保存每个位置的值。
 * 然后从初始的三个值开始，逐步计算到n的位置。
 *
 * <ul>比如说，当n是4的时候，计算过程是这样的：
 *     <li/>T0=0，T1=1，T2=1； <br/>
 *     <li/>T3 = T0 + T1 + T2 = 0+1+1=2； <br/>
 *     <li/>T4 = T1 + T2 + T3 =1+1+2=4； <br/>
 * </ul>
 * <p>
 * 那如果用动态规划的方法，状态转移方程应该怎么写？状态转移方程应该是dp[i] = dp[i-3] + dp[i-2] + dp[i-1]。这样，每个位置i的值是前三项之和。初始条件是dp[0]=0，dp[1]=1，dp[2]=1。
 * <p>
 * 那这时候需要考虑不同的n的情况。比如当n小于3的时候，直接返回对应的初始值。如果n大于等于3，就需要逐步计算到n的位置。
 * <p>
 * 那这个时候，我可以初始化一个数组，长度是n+1（假设n>=3）。然后从3开始循环到n，每次计算当前项的值。这样可以避免重复计算，时间复杂度是O(n)，空间复杂度也是O(n)。
 * 那有没有可能优化空间呢？因为每个计算只需要前三项的值，所以可以不用数组，而是用三个变量来保存前三项的值，这样空间复杂度可以降到O(1)。
 * <p>
 * 比如，用a，b，c分别表示Tn-3，Tn-2，Tn-1。但是这可能有点混乱，或者需要用循环来不断更新这三个变量。
 * 或者更简单一点，可以用四个变量，比如prev3，prev2，prev1，然后当前的值是这三个之和。然后每次循环的时候，更新这三个变量。
 * 例如，初始时，当n=0，返回0；n=1或2，返回1。当n>=3时，从3开始计算到n，每次计算当前值，然后更新变量。比如，初始的三个变量是T0=0，T1=1，T2=1。
 * 然后计算T3的时候是这三个的和。接下来，对于T4来说，需要T1，T2，T3的和。这时候，可以把这三个变量更新为原来的T1，T2，以及新计算的T3。然后继续循环。
 * <p>
 * 这样的话，空间复杂度就是O(1)，时间还是O(n)。这可能更好，特别是当n非常大的时候，比如n是几万或更大，这样不会占用太多内存。
 * <p>
 * 那现在具体怎么实现呢？比如，当n是25的时候，需要循环到第25项。我们可以用三个变量来保存前三项的值。例如：
 * 初始化：<p>
 * a = T0 = 0 <br/>
 * b = T1 =1 <br/>
 * c = T2=1 <br/>
 * <p>
 * 如果n是0，返回a；n是1返回b；n是2返回c。
 * <p>
 * 对于n>=3的情况，从3循环到n，每次计算d = a +b +c。然后更新a为原来的b，b为原来的c，c为d。这样循环下去，直到i达到n的时候，此时的d就是Tn的值。
 * <p>
 * <p/>
 * Copyright: Copyright (c) 2025-03-26 8:25
 * <p/>
 * Company: Sexy Uncle Inc.
 * <p/>
 *
 * @author Rico Yu  ricoyu520@gmail.com
 * @version 1.0
 */
public class Tribonacci {

	public int tribonacci(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		int t0 = 0, t1 = 1, t2 = 1;

		int current = 0;
		for (int i = 3; i <= n; i++) {
			current = t0 + t1 + t2;
			t0 = t1;
			t1 = t2;
			t2 = current;
		}

		return current;
	}
}
