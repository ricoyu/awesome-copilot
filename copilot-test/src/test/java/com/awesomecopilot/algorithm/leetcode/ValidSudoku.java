package com.awesomecopilot.algorithm.leetcode;

/**
 * 有效的数独
 * <p>
 * 请你判断一个 9 x 9 的数独是否有效。只需要根据以下规则, 验证已经填入的数字是否有效即可。
 * <p>
 * 数字 1-9 在每一行只能出现一次。<br/>
 * 数字 1-9 在每一列只能出现一次。<br/>
 * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 * <p>
 * 注意：
 * <p>
 * 一个有效的数独（部分已被填充）不一定是可解的。<br/>
 * 只需要根据以上规则，验证已经填入的数字是否有效即可。<br/>
 * 空白格用 '.' 表示。
 * <p>
 * 示例 1：
 * <pre>
 * 输入：board =
 * [["5","3",".",".","7",".",".",".","."]
 * ,["6",".",".","1","9","5",".",".","."]
 * ,[".","9","8",".",".",".",".","6","."]
 * ,["8",".",".",".","6",".",".",".","3"]
 * ,["4",".",".","8",".","3",".",".","1"]
 * ,["7",".",".",".","2",".",".",".","6"]
 * ,[".","6",".",".",".",".","2","8","."]
 * ,[".",".",".","4","1","9",".",".","5"]
 * ,[".",".",".",".","8",".",".","7","9"]]
 * 输出：true
 * </pre>
 * <p>
 * 示例 2：
 * <pre>
 * 输入：board =
 * [["8","3",".",".","7",".",".",".","."]
 * ,["6",".",".","1","9","5",".",".","."]
 * ,[".","9","8",".",".",".",".","6","."]
 * ,["8",".",".",".","6",".",".",".","3"]
 * ,["4",".",".","8",".","3",".",".","1"]
 * ,["7",".",".",".","2",".",".",".","6"]
 * ,[".","6",".",".",".",".","2","8","."]
 * ,[".",".",".","4","1","9",".",".","5"]
 * ,[".",".",".",".","8",".",".","7","9"]]
 * 输出：false
 * </pre>
 * 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
 *
 * <ol>解题思路
 *     <ul>数据结构选择：使用三个二维布尔数组（行、列、子宫格），分别记录对应位置是否已出现某个数字：
 *         <li/>row[i][num]：第 i 行是否出现数字 num
 *         <li/>col[j][num]：第 j 列是否出现数字 num
 *         <li/>box[k][num]：第 k 个 3x3 子宫格是否出现数字 num
 *     </ul>
 *     <li/>子宫格编号计算：对于位置 (i,j)，子宫格编号 k = (i/3)*3 + j/3（整数除法），例如 (0,0) 属于 0 号宫，(0,3) 属于 1 号宫，(3,0) 属于 3 号宫。
 *     <li/>遍历验证：遍历数独每个位置，若为数字则检查行、列、宫是否已存在该数字，存在则返回 false，否则标记为已存在；遍历完成返回 true。
 *     <li/>
 * </ol>
 * <p/>
 * Copyright: Copyright (c) 2025-12-23 9:21
 * <p/>
 * Company: Sexy Uncle Inc.
 * <p/>
 *
 * @author Rico Yu  ricoyu520@gmail.com
 * @version 1.0
 */
public class ValidSudoku {

	public static void main(String[] args) {
		ValidSudoku validator = new ValidSudoku();
		// 示例1：有效数独
		char[][] validBoard = {
				{'5','3','.','.','7','.','.','.','.'},
				{'6','.','.','1','9','5','.','.','.'},
				{'.','9','8','.','.','.','.','6','.'},
				{'8','.','.','.','6','.','.','.','3'},
				{'4','.','.','8','.','3','.','.','1'},
				{'7','.','.','.','2','.','.','.','6'},
				{'.','6','.','.','.','.','2','8','.'},
				{'.','.','.','4','1','9','.','.','5'},
				{'.','.','.','.','8','.','.','7','9'}
		};
		System.out.println("示例1结果：" + validator.isValidSudoku(validBoard)); // 输出true

		// 示例2：无效数独（第一行第一个数字改为8，与第三行第三个8同宫）
		char[][] invalidBoard = {
				{'8','3','.','.','7','.','.','.','.'},
				{'6','.','.','1','9','5','.','.','.'},
				{'.','9','8','.','.','.','.','6','.'},
				{'8','.','.','.','6','.','.','.','3'},
				{'4','.','.','8','.','3','.','.','1'},
				{'7','.','.','.','2','.','.','.','6'},
				{'.','6','.','.','.','.','2','8','.'},
				{'.','.','.','4','1','9','.','.','5'},
				{'.','.','.','.','8','.','.','7','9'}
		};
		System.out.println("示例2结果：" + validator.isValidSudoku(invalidBoard)); // 输出false
	}

	/**
	 * 判断9x9数独是否有效
	 *
	 * @param board 9x9的数独数组，空白格为'.'
	 * @return 符合规则返回true，否则返回false
	 */
	public boolean isValidSudoku(char[][] board) {
		// 行数和列数固定为9
		int n = 9;
		// 行验证：row[i][num] 表示第i行是否出现数字num（num范围1-9，数组索引0不用）
		boolean[][] row = new boolean[n][n + 1];
		// 列验证：col[j][num] 表示第j列是否出现数字num
		boolean[][] col = new boolean[n][n + 1];
		// 3x3宫验证：box[k][num] 表示第k个宫是否出现数字num，宫编号0-8
		boolean[][] box = new boolean[n][n + 1];

		// 遍历数独的每个位置
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				// 跳过空白格
				if (board[i][j] == '.') {
					continue;
				}

				// 将字符型数字转换为整数（如'5'->5）
				int num = board[i][j] - '0';
				// 计算当前位置所属的3x3宫编号
				int boxIndex = (i / 3) * 3 + j / 3;

				// 检查行、列、宫是否已存在该数字，存在则数独无效
				if (row[i][num] || col[j][num] || box[boxIndex][num]) {
					return false;
				}

				// 标记该数字在对应行、列、宫已出现
				row[i][num] = true;
				col[j][num] = true;
				box[boxIndex][num] = true;
			}
		}
		// 所有已填数字都符合规则
		return true;
	}
}
